# -*- coding: utf-8 -*-
"""Chatbot Using OpenAI Assistant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iO_zom4ypeDHg2FePHKcRQMEjp69ogB0
"""

# pip install rapidfuzz

from openai import OpenAI
from dotenv import load_dotenv
import os
import time,json

load_dotenv()

api_key = os.getenv("API_KEY")
client = OpenAI(
    api_key = api_key
)

file_path = 'master_json.json'

with open(file_path, 'r') as file:
    PRODUCT_DATA = json.load(file)

# print(PRODUCT_DATA.keys())

def get_pricing_data(product_data, workloads=None, tier=None):
    filtered_data = [item for item in product_data if "Type" in item]
    tier_data = [item for item in filtered_data if item["Type"].lower() == tier.lower()]
    return tier_data

def first_data(tier_data,workloads):
    second_key = list(tier_data[0].keys())[1]
    sorted_data = sorted(tier_data, key=lambda x: abs(x[second_key] - workloads))
    return sorted_data[0]


def calculate_mean_price(entry):
    # print("entry",entry)
    cost_str = entry['Cost'].strip()
    cost_str = cost_str.replace('$', '').replace('Rs', '').strip()
    if "-" not in cost_str:
       return float(cost_str.strip().split()[0])
    numbers = cost_str.split(' - ')
    min_cost = int(numbers[0].replace('k', '000').strip())  # Handle 'k' for thousands
    max_cost = int(numbers[1].replace('k', '000').strip().split()[0])  # Handle text after the second number
    mean_price = (min_cost + max_cost) / 2
    return mean_price



def fetch_pricing(product,workloads=None,tier=None):
    try:
      recognized_product = product.lower()
      global PRODUCT_DATA
      # match = process.extractOne(product, PRODUCT_DATA.keys(), score_cutoff=50)
      PRODUCT_DATA = {key.lower(): value for key, value in PRODUCT_DATA.items()}
      if recognized_product not in PRODUCT_DATA.keys():
          return f"Error: Product '{product}' is not recognized. Please provide a valid product name by refeering to Available Products."
      product_data = PRODUCT_DATA[recognized_product]
      filtered_data = [item for item in product_data if "Type" in item]
      if workloads == None and tier == None:
          # print(product_data)
          available_tiers = {item["Type"] for item in filtered_data}
          tier = filtered_data[0].get("Type", "") if filtered_data else ""
          default_workloads = 500
          tier_data = get_pricing_data(product_data,default_workloads,tier)
          second_key = list(tier_data[0].keys())[1]
          nearest_entry = first_data(tier_data,default_workloads)
          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          # return f"The default tier is {tier} and the default {second_key} is {default_workloads}.Should I proceed with the same? Or can you specify your {second_key} and the tier for a customised price. Available tiers: {', '.join(available_tiers)}"
          return f"The pricing for default tier {tier} and default {second_key}- {default_workloads} is {offer_price}.Please provide your {second_key} and tiers for a customised price.Available tiers: {', '.join(available_tiers)}"
      elif workloads == None:
          default_workloads = 500
          tier_data = get_pricing_data(product_data,default_workloads,tier)
          if not tier_data:
            available_tiers = {item["Type"] for item in filtered_data}
            return f"No data available for tier '{tier}'. Available tiers: {', '.join(available_tiers)}."
          second_key = list(tier_data[0].keys())[1]
          nearest_entry = first_data(tier_data,default_workloads)
          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          # return f"The default {second_key} is {default_workloads}.Should I proceed with the same? Or can you specify your {second_key} for a customised price"
          return f"The pricing for tier {tier} and default {second_key}- {default_workloads} is {offer_price}.Please provide your {second_key} for a customised price."
          
          
      elif tier == None:
          tier = filtered_data[0].get("Type", "")
          available_tiers = {item["Type"] for item in filtered_data}
          tier_data = get_pricing_data(product_data,workloads,tier)
          second_key = list(tier_data[0].keys())[1]
          nearest_entry = first_data(tier_data,workloads)
          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          # return f"The default tier is {tier}.Should I proceed with the same? Or can you specify your tier for a customised price. Available tiers: {', '.join(available_tiers)}"
          return f"The pricing for default tier-{tier} and {second_key}- {workloads} is {offer_price}.Please provide your tier for a customised price.Available tiers: {', '.join(available_tiers)}"
      else:
          tier_data = get_pricing_data(product_data,workloads,tier)
          second_key = list(tier_data[0].keys())[1]
          if not tier_data:
            available_tiers = {item["Type"] for item in filtered_data}
            return f"No data available for tier '{tier}'. Available tiers: {', '.join(available_tiers)}."
          nearest_entry = first_data(tier_data,workloads)
          # print("nearest_entry",nearest_entry)

          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          return f"The price of {recognized_product} for {tier}-tier, for {workloads} {second_key} is {offer_price}"
    except:
      return "Something went wrong. Try reloading the page or try after some time."
    

def year_end_sales(product,workloads=None,tier=None):
    try:
      discount_percentage = 20
      recognized_product = product.lower()
      global PRODUCT_DATA
      PRODUCT_DATA = {key.lower(): value for key, value in PRODUCT_DATA.items()}
      if recognized_product not in PRODUCT_DATA.keys():
        return f"Error: Product '{product}' is not recognized. Please provide a valid product name by refeering to Available Products."
      product_data = PRODUCT_DATA[recognized_product]
      filtered_data = [item for item in product_data if "Type" in item]
      available_tiers = {item["Type"] for item in filtered_data}

      if workloads == None and tier == None:
          tier = filtered_data[0].get("Type", "")
          default_workloads = 500
          tier_data = get_pricing_data(product_data,default_workloads,tier)
          second_key = list(tier_data[0].keys())[1]
          second_key = list(tier_data[0].keys())[1]
          nearest_entry = first_data(tier_data,default_workloads)
          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          year_end_price = round(offer_price - (mean_price * discount_percentage/100),2)
          return f"The year-end-sales pricing for default tier {tier} and default {second_key}- {default_workloads} is {year_end_price} at {discount_percentage} discount.Please provide your {second_key} and tiers for a customised price.Available tiers: {', '.join(available_tiers)}"
          # return f"The default tier is {tier} and the default {second_key} is {default_workloads}.Should I proceed with the same? Or can you specify your {second_key} and the tier for a customised price in year-end sales. Available tiers: {', '.join(available_tiers)}"
      elif workloads == None:
          default_workloads = 500
          tier_data = get_pricing_data(product_data,default_workloads,tier)
          if not tier_data:
            available_tiers = {item["Type"] for item in filtered_data}
            return f"No data available for tier '{tier}'. Available tiers: {', '.join(available_tiers)}."
          second_key = list(tier_data[0].keys())[1]
          nearest_entry = first_data(tier_data,default_workloads)
          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          year_end_price = round(offer_price - (mean_price * discount_percentage/100),2)
          return f"The year-end-sales pricing for tier {tier} and default {second_key}- {default_workloads} is {year_end_price} at {discount_percentage} discount.Please provide your {second_key} for a customised price."
          
          # return f"The default {second_key} is {default_workloads}.Should I proceed with the same? Or can you specify your {second_key} for a customised price in year-end sales."
          
      elif tier == None:
          tier = filtered_data[0].get("Type", "")
          tier_data = get_pricing_data(product_data,workloads,tier)
          # if not tier_data:
          #   available_tiers = {item["Type"] for item in filtered_data}
          #   return f"No data available for tier '{tier}'. Available tiers: {', '.join(available_tiers)}."
          second_key = list(tier_data[0].keys())[1]
          nearest_entry = first_data(tier_data,workloads)
          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          year_end_price = round(offer_price - (mean_price * discount_percentage/100),2)
          return f"The yyear-end-sales pricing for default tier-{tier} and {second_key}- {workloads} is {year_end_price} at {discount_percentage} discount.Please provide your tier for a customised price.Available tiers: {', '.join(available_tiers)}"
          
          # return f"The default tier is {tier}.Should I proceed with the same? Or can you specify your tier for a customised price in year-end sales. Available tiers: {', '.join(available_tiers)}"
      else:
          tier_data = get_pricing_data(product_data,workloads,tier)
          second_key = list(tier_data[0].keys())[1]
          if not tier_data:
            available_tiers = {item["Type"] for item in product_data}
            return f"No data available for tier '{tier}'. Available tiers: {', '.join(available_tiers)}."
          nearest_entry = first_data(tier_data,workloads)
          mean_price = calculate_mean_price(nearest_entry)
          offer_price = round(mean_price * 1.1, 2)
          year_end_price = round(offer_price - (mean_price * discount_percentage/100),2)
          return f"The price of {recognized_product} for {tier} tier, for {workloads} workloads is {year_end_price} at {discount_percentage} discount in year-end-sales."
    except:
      return "Something went wrong. Try reloading the page or try after some time."
def product_query(product):
    try:
      recognized_product = product.lower()
      default_workloads = 500
      global PRODUCT_DATA,flag
      PRODUCT_DATA = {key.lower(): value for key, value in PRODUCT_DATA.items()}
      if recognized_product not in PRODUCT_DATA.keys():
        return f'Seems you haven\'t selected the product from Available Products Menu. Please try again.'
      product_data = PRODUCT_DATA[recognized_product]
      filtered_data = [item for item in product_data if "Type" in item]
      available_tiers = {item["Type"] for item in filtered_data}
      tier = filtered_data[0].get("Type", "")
      tier_data = get_pricing_data(product_data,default_workloads,tier)
      second_key = list(tier_data[0].keys())[1]
      nearest_entry = first_data(tier_data,default_workloads)
      print("nearest_entry",nearest_entry)
      mean_price = calculate_mean_price(nearest_entry)
      return f"The price for the workload- {default_workloads} and tier- {tier} is {mean_price}. Please provide additional context that is {second_key} and tiers for your customised pricing.Available tiers: {', '.join(available_tiers)}."
    except:
      return "Something went wrong. Try reloading the page or try after some time."

def query_other_than_pricing_reviews():
    try:
      return f"The Agent is designed specifically for retrieving pricing information and fetching reviews for SaaS products. Unfortunately, it cannot assist with other features or aspects other than fetching reviews or prices. Let me know if you have any pricing-related queries!"
    except:
      return "Something went wrong. Try reloading the page or try after some time."
      
  
def query_on_reviews():
    try:
      return f"This is a Pricing Agent.I see you are looking for reviews . Kindly change your service to \"Reviews\" & let our Review Agent assist you"
    except:
      return "Something went wrong. Try reloading the page or try after some time."
  




available_functions = {
    "fetch_pricing": fetch_pricing,
    "year_end_sales": year_end_sales,
    "query_other_than_pricing": query_other_than_pricing_reviews,
    "query_on_reviews": query_on_reviews,
    "product_query": product_query
}

tools = [
    {
        "type": "function",
        "function": {
            "name": "fetch_pricing",
            "description": "Retrieves the price of SaaS Products with respect to specific workloads and tiers. It may be the case when only the product name is given by the user without any additional context.",
            "parameters": {
                "type": "object",
                "properties": {
                    "workloads": {
                        "type": "integer",
                        "description": "This is not a required parameter. It is the number of workloads for which to extract the price. Users' companies have different workloads for which they want to fetch the price for a particular product. Workloads can sometimes be termed as units/employees."
                    },
                    "product": {
                        "type": "string",
                        "description": "It is a required parameter. It is the product for which the user wants to fetch price details."
                    },
                    "tier": {
                        "type": "string",
                        "description": "This is not a required parameter. It is the tier of the product for which the user wants to fetch price details."
                    }
                },
                "required": ["product"],
                "examples": [
                    {
                        "description": "Fetch the price for CRM Pro for 1000 workloads in the Enterprise tier.",
                        "parameters": {
                            "product": "CRM Pro",
                            "workloads": 1000,
                            "tier": "Enterprise"
                        }
                    },
                    {
                        "description": "Analytics Suite.",
                        "parameters": {
                            "product": "Analytics Suite",
                            "workloads": None,
                            "tier": None
                        }
                    }
                ]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "year_end_sales",
            "description": "Fetches the price during year-end sales or when asked for negotiation during the year-end sales based on the discount percent provided.",
            "parameters": {
                "type": "object",
                "properties": {
                    "product": {
                        "type": "string",
                        "description": "This is a required parameter. It is the product for which year-end sale pricing is to be given."
                    },
                    "workloads": {
                        "type": "integer",
                        "description": "This is not a required parameter. It is the number of workloads for which to extract the year-end sale pricing."
                    },
                    "tier": {
                        "type": "string",
                        "description": "This is not a required parameter. It is the tier of the product for which the user wants to fetch price details."
                    }
                },
                "required": ["product"],
                "examples": [
                    {
                        "description": "Retrieve the price of CRM Pro for 1000 workloads for Enterprise tier at year-end sales.",
                        "parameters": {
                            "product": "CRM Pro",
                            "workloads": 1000,
                            "tier": "Enterprise"
                        }
                    }
                ]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "query_other_than_pricing_reviews",
            "description": "Responds to queries that are not related to SaaS pricing or reviews and clarifies the agent's purpose.",
            "parameters": {
                "type": "object",
                "properties": {
                    # "product": {
                    #     "type": "string",
                    #     "description": "This is a required parameter. It is the product for which a feature/aspect is asked that is not relevant to pricing or reviews."
                    # }
                },
                "examples": [
                    {
                        "description": "What are the features of Wiz?",
                        "parameters": {
                            # "product": "Wiz"
                        }
                    }
                ]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "query_on_reviews",
            "description": "Responds to queries related to reviews and clarifies the agent's purpose.I Like if user ask for reviews or merits, demerits or any other genral overview but not pricing",
            "parameters": {
                "type": "object",
                "properties": {
                    # "product": {
                    #     "type": "string",
                    #     "description": "This is a required parameter. It is the product for which reviews are asked."
                    # }
                },
                "examples": [
                    {
                        "description": "Can you generate reviews of CRM Pro?",
                        "parameters": {
                        }
                    }
                ]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "product_query",
            "description": "Responds to user if an user enters/selects the Saas product name from the Available Products menu",
            "parameters": {
                "type": "object",
                "properties": {
                    "product": {
                        "type": "string",
                        "description": "This is a required parameter. It is the product which the user enters.."
                    }
                },
                "required": ["product"],
                "examples": [
                    {
                        "description": "Wiz?",
                        "parameters": {
                            "product": "Wiz"
                        }
                    }
                ]
            }
        }
    }
    
]

assistant = client.beta.assistants.create(
  name="SAAS vendor bot",
  instructions="You are a SAAS vendor bot. Use the provided functions to answer questions. Synthesise answer based on provided function output and be consise",
  model="gpt-4o-mini",
  tools = tools
)


def create_message_and_run(assistant,query,thread=None):
  # print("The thread I received:", thread)
  if thread == None:
    # print("Generating new thread")
    thread = client.beta.threads.create()
 
  message = client.beta.threads.messages.create(
    thread_id=thread.id,
    role="user",
    content=query
  )
  run = client.beta.threads.runs.create(
  thread_id=thread.id,
  assistant_id=assistant.id
  )
  return run,thread

def get_function_details(run):

 

  required_actions = run.required_action.submit_tool_outputs.model_dump()



  return required_actions

def execute_function_call(required_actions):
    tools_output = []
    
    tool_calls_list = required_actions["tool_calls"]
    for action in tool_calls_list:
        function_name = action["function"]["name"]
        arguments = action["function"]["arguments"]
        print(type(arguments))
        print("func_name",function_name)
        print("arguments",arguments)
        
        
        function = available_functions.get(function_name,None)
        if not function:
            results = f"Error: function {function_name} does not exist"
            return results

        else:
      # if function:
          arguments = json.loads(arguments)
          results = function(**arguments)
          output = json.dumps(results) if not isinstance(results, str) else results
          tools_output.append({
                      "tool_call_id": action["id"],
                      "output": output
                  })
    return tools_output

   

def submit_tool_outputs(run,thread,tools_output):
    run = client.beta.threads.runs.submit_tool_outputs(
    thread_id=thread.id,
    run_id=run.id,
    tool_outputs=tools_output
    )
    return run

def process_query(query, assistant=assistant, client=client, thread=None):
    
    try:
  
        run, thread = create_message_and_run(assistant=assistant,query=query, thread=thread)
        
        while True:
            run = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)

            if run.status=="requires_action":
                required_actions = get_function_details(run)
                tool_outputs= execute_function_call(required_actions)
                
                
                run = submit_tool_outputs(run,thread,tool_outputs)

                continue
            if run.status=="completed":
                print(run.status)
                messages = client.beta.threads.messages.list(thread_id=thread.id)
                latest_message = messages.data[0]
                text = latest_message.content[0].text.value
                return text, thread
    
    except:
            return "Some error occured. Plz reload the page or try after some time",thread
        
    

      





